"""
Adapt/extend autotest.client.test.test for Docker test sub-framework
Implement docker subtest base to avoid circular dependences in dockertest core
modules.
"""

# Pylint runs from a different directory, it's fine to import this way
# pylint: disable=W0403

import os.path
import csv
import logging
import traceback
from environment import docker_rpm
from xceptions import DockerTestFail
from xceptions import DockerTestNAError
from config import get_as_list, CONFIGCUSTOMS


def known_failures():
    """
    Returns a dict containing known test failures. Primary key is
    subtest name (e.g. docker_cli/foo/bar), value is another dict
    whose key is docker NVRA (e.g. docker-1.12.5-8.el7.x86_64),
    value of that is a string description of the problem (e.g.
    a bz number and comment).
    """
    known = {}
    path_known = os.path.join(CONFIGCUSTOMS, 'known_failures.csv')
    with open(path_known, 'rb') as csv_fh:
        csv_reader = csv.reader(csv_fh)
        for row in csv_reader:
            if row[1] not in known:
                known[row[1]] = {}
            # Each row is: NVR, subtest, description
            known[row[1]][row[0]] = row[2]
    return known


class SubBase(object):

    """
    Methods/attributes common to Subtest & SubSubtest classes

    :note: This class is indirectly referenced by the control-file
           so it cannot contain anything dockertest-implementation
           specific.
    """

    #: Configuration section for subclass, auto-generated by ``__init__``.
    config_section = None

    #: Configuration dictionary (read-only for instances)
    config = None

    #: Unique temporary directory for this instance (automatically cleaned up)
    #: **warning**: DO NOT ASSUME DIRECTORY WILL BE EMPTY!!!
    tmpdir = None

    #: Number of additional space/tab characters to prefix when logging
    n_spaces = 16  # date/timestamp length

    #: Number of additional space/tab characters to prefix when logging
    n_tabs = 1     # one-level

    step_log_msgs = {
        "initialize": "initialize()",
        "run_once": "run_once()",
        "postprocess": "postprocess()",
        "cleanup": "cleanup()"
    }

    #: Path to file indicating which Red Hat release this is
    redhat_release_filepath = "/etc/redhat-release"

    def __init__(self, *args, **dargs):
        super(SubBase, self).__init__(*args, **dargs)
        self.step_log_msgs = self.step_log_msgs.copy()

    def initialize(self):
        """
        Called every time the test is run.
        """
        self.log_step_msg('initialize')
        # Issue warnings for failed to customize suggested options
        not_customized = self.config.get('__example__', None)
        if not_customized is not None and not_customized is not '':
            self.logdebug("WARNING: Recommended options not customized:")
            for nco in get_as_list(not_customized):
                self.logdebug("WARNING: %s" % nco)
            self.logwarning("WARNING: Test results may be externally "
                            "dependent! (See debug log for details)")
        msg = "%s configuration:\n" % self.__class__.__name__
        for key, value in self.config.items():
            if key == '__example__' or key.startswith('envcheck'):
                continue
            msg += '\t\t%s = "%s"\n' % (key, value)
        self.logdebug(msg)

    def run_once(self):
        """
        Called once only to exercise subject of sub-subtest
        """
        self.log_step_msg('run_once')

    def postprocess(self):
        """
        Called to process results of subject
        """
        self.log_step_msg('postprocess')

    def cleanup(self):
        """
        Always called, before any exceptions thrown are re-raised.
        """
        self.log_step_msg('cleanup')

    def log_step_msg(self, stepname):
        """
        Send message stored in ``step_log_msgs`` key ``stepname`` to logingo
        """
        msg = self.step_log_msgs.get(stepname)
        if msg:
            self.loginfo(msg)

    def is_known_failure(self, subthingname):
        """
        Do we have a registered known failure in this subtest/sub-subtest
        when running on the currently-installed docker? Return True if so.

        :param subthingname: Subtest/sub-subtest name to search for
        :returns: True/False if a match to active docker NVRA found
        :SideEffect: log warning messages to help human debuggers.
        """
        # e.g. docker_cli/subtest/subsubtest
        fullname = os.path.join(self.config_section, subthingname)
        known = known_failures()
        if fullname not in known:
            return False
        docker_nvr = docker_rpm()
        if docker_nvr in known[fullname]:
            why = known[fullname][docker_nvr]
            self.logwarning("%s: Known failure on %s: %s",
                            subthingname, docker_nvr, why)
            return True

        # This exact NVR is not known to fail. What about NV?
        _nv = lambda nvr: nvr[:nvr.rfind('-')]
        docker_nv = _nv(docker_nvr)
        docker_nv_wild = docker_nv + '-*'
        if docker_nv_wild in known[fullname]:
            why = known[fullname][docker_nv_wild]
            self.logwarning("%s expected to fail on all builds of %s: %s",
                            subthingname, docker_nv, why)
            return True

        # No known failures for NVR or NV. What about other builds of same NV
        # or a related one? These messages are informational only, intended
        # as hints for a test engineer trying to understand new failures.
        if docker_nv in [_nv(x) for x in known[fullname]]:
            # e.g. docker is 1.12.5-6, we have an exception for 1.12.5->>5<<
            self.logwarning("%s is known to fail in other %s builds",
                            subthingname, docker_nv)
        elif docker_nv.count('.') > 1:
            _nv_base = lambda nv_orig: nv_orig[:nv_orig.rfind('.')]
            docker_nv_base = _nv_base(docker_nv)
            if docker_nv_base in [_nv_base(_nv(x)) for x in known[fullname]]:
                # e.g. docker is 1.12.6-1, we have exception for 1.12.>>5<<-*
                self.logwarning("%s is known to fail in other %s.x builds",
                                subthingname, docker_nv_base)
        return False

    @staticmethod
    def failif(condition, reason=None):
        """
        Convenience method for subtests to avoid importing ``TestFail``
        exception

        :param condition: Boolean condition, fail test if True.
        :param reason: Helpful text describing why the test failed
        :raise DockerTestFail: If condition evaluates ``True``
        """

        if reason is None:
            reason = "Failed test condition"
        if bool(condition):
            raise DockerTestFail(reason)

    @staticmethod
    def failif_ne(actual, expected, reason=None):
        """
        Convenience method for subtests to compare two values and
        fail if they differ. Failure message will include the expected
        and actual values for ease of debugging.

        :param actual: value being tested
        :param expected: value to which we compare.
        :param reason: Helpful text describing why the test failed
        :raise DockerTestFail: If actual != expected
        """

        if actual == expected:
            return
        if reason is None:
            reason = "Failed test condition"

        # By default, quote each value. This is especially helpful when
        # actual or expected is the empty string or a string with spaces.
        # But if both are numeric types the quotes distract, so remove them.
        arg = "'{}'"
        if all(isinstance(x, (int, long, float)) for x in [actual, expected]):
            arg = "{}"
        spec = "{}: expected " + arg + "; got " + arg
        raise DockerTestFail(spec.format(reason, expected, actual))

    @staticmethod
    def failif_not_in(needle, haystack, description=None):
        """
        Convenience method for subtests to test for an expected substring
        being contained in a larger string, e.g. to look for XYZ in a
        command's stdout/stderr.

        :param needle: the string you're looking for. May be a list of
                       multiple strings separated by '|' and optional
                       whitespace, e.g. 'needle | fiddle | doo wah diddy'
        :param haystack: the actual string, e.g stdout results from a command
        :param description: description of haystack, e.g. 'stdout from foo'
        :raise DockerTestFail: if needle is not found in haystack
        """
        if description is None:
            description = 'string'
        if needle in haystack:
            return
        expect_s = "Expected string '%s'" % needle
        if '|' in needle:
            needles = [n.strip() for n in needle.split('|')]
            expect_s = "Expected strings %s" % needles
            for subneedle in needles:
                if subneedle.strip() in haystack:
                    return
        raise DockerTestFail("%s not in %s '%s'" %
                             (expect_s, description, haystack))

    @classmethod
    def failif_not_redhat(cls, xcept=DockerTestNAError):
        """
        Raises an exception if this is a non-RHEL/RHELAH System

        :param xcept: Non-default exception to raise
        :raise DockerTestNAError: By default
        """
        try:
            with open(cls.redhat_release_filepath, 'rb') as rhrel:
                if 'Enterprise' not in rhrel.read():
                    raise xcept("Test only intended for a Red Hat "
                                "Enterprise Linux System.")
        except IOError, anotherone:
            raise xcept("Is this a Red Hat Enterprise system?  "
                        "Error reading %s: %s."
                        % (cls.redhat_release_filepath,
                           str(anotherone)))

    @classmethod
    def log_x(cls, lvl, msg, *args):
        """
        Send ``msg`` & ``args`` through to logging module function with
        name ``lvl``
        """

        meth = getattr(logging, lvl)
        testname = cls.__name__
        return meth("%s%s: %s" % ("\t" * cls.n_tabs, testname, msg), *args)

    @classmethod
    def log_xn(cls, lvl, msg, *args):
        """
        Multiline-split and send msg & args through to logging module

        :param lvl: logging method name (``'debug'``, ``'info'``, etc.)
        :param msg: Message format-string
        """
        # date, loglevel, this module offset
        newline = '\n' + ' ' * cls.n_spaces + '\t' * cls.n_tabs
        newline += " " * (len(cls.__name__) + 2)    # cls name + ': '
        try:
            msg = (str(msg) % args).replace('\n', newline)
        except TypeError:
            if args is tuple():
                cls.logwarning("Following message contains format strings but "
                               "has no arguments:")
                msg = str(msg).replace('\n', newline)
            else:
                raise TypeError("Not all arguments converted during formatting"
                                ": msg='%s', args=%s" % (msg, args))
        return cls.log_x(lvl, msg)

    @classmethod
    def logdebug(cls, message, *args):
        r"""
        Log a DEBUG level message to the controlling terminal **only**

        :param message: Same as ``logging.debug()``
        :param \*args: Same as ``logging.debug()``
        """
        # Never split over multiple lines
        cls.log_x('debug', message, *args)

    @classmethod
    def loginfo(cls, message, *args):
        r"""
        Log a INFO level message to the controlling terminal **only**

        :param message: Same as ``logging.info()``
        :param \*args: Same as ``logging.info()``
        """
        cls.log_xn('info', message, *args)

    @classmethod
    def logwarning(cls, message, *args):
        r"""
        Log a WARNING level message to the controlling terminal **only**

        :param message: Same as ``logging.warning()``
        :param \*args: Same as ``logging.warning()``
        """
        cls.log_xn('warn', message, *args)

    @classmethod
    def logerror(cls, message, *args):
        r"""
        Log a ERROR level message to the controlling terminal **only**

        :param message: Same as ``logging.error()``
        :param \*args: Same as ``logging.error()``
        """
        cls.log_xn('error', message, *args)

    @classmethod
    def logtraceback(cls, name, exc_info, error_source, detail):
        r"""
        Log error to error, traceback to debug, of controlling terminal
        **only**
        """
        error_head = ("%s failed to %s\n%s\n%s" % (name, error_source,
                                                   detail.__class__.__name__,
                                                   detail))
        error_tb = traceback.format_exception(exc_info[0],
                                              exc_info[1],
                                              exc_info[2])

        error_tb_str = "".join(error_tb).strip() + "\n"
        cls.logerror(error_head)
        cls.logdebug(error_tb_str)
